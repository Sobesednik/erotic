{"version":3,"sources":["../src/lib.js"],"names":["getLastItem","array","item","length","getItemsFrom","from","slice","getStackSegment","stack","oneLine","splitStack","split","Number","Infinity","line","items","join","getEntryStack","transparent","stackSegment","getCalleeStackLine","calleeStackLine","getStackHeading","message","getCallerFromArguments","args","callee","caller"],"mappings":";;;;;AAAA,MAAMA,cAAeC,KAAD,IAAW;AAC7B,QAAMC,OAAOD,MAAMA,MAAME,MAAN,GAAe,CAArB,CAAb;AACA,SAAOD,IAAP;AACD,CAHD;;AAIA,MAAME,eAAe,CAACH,KAAD,EAAQI,IAAR,KAAiBJ,MAAMK,KAAN,CAAYD,IAAZ,CAAtC;AAEA;;;;;;;;;AAOO,MAAME,kBAAkB,CAACC,KAAD,EAAQH,OAAO,CAAf,EAAkBI,UAAU,KAA5B,KAAsC;AACnE,MAAIJ,SAAS,CAAT,IAAc,CAACI,OAAnB,EAA4B;AAC1B,WAAOD,KAAP;AACD;;AACD,QAAME,aAAaF,MAChBG,KADgB,CACV,IADU,EACJF,UAAUJ,OAAO,CAAjB,GAAqBO,OAAOC,QADxB,CAAnB;;AAEA,MAAIJ,OAAJ,EAAa;AACX,UAAMK,OAAOd,YAAYU,UAAZ,CAAb;AACA,WAAOI,IAAP;AACD,GAHD,MAGO;AACL,UAAMC,QAAQX,aAAaM,UAAb,EAAyBL,IAAzB,CAAd;AACA,WAAOU,MAAMC,IAAN,CAAW,IAAX,CAAP;AACD;AACF,CAbM;AAeP;;;;;;;;;;;;AAQO,MAAMC,gBAAgB,CAACT,KAAD,EAAQU,WAAR,KAAwB;AACnD,QAAMC,eAAeZ,gBAAgBC,KAAhB,EAAuB,KAAKU,cAAc,CAAd,GAAkB,CAAvB,CAAvB,CAArB;AACA,SAAOC,YAAP;AACD,CAHM;AAKP;;;;;;;;;AAKO,MAAMC,qBAAsBZ,KAAD,IAAW;AAC3C,QAAMa,kBAAkBd,gBAAgBC,KAAhB,EAAuB,CAAvB,EAA0B,IAA1B,CAAxB;AACA,SAAOa,eAAP;AACD,CAHM;;;;AAKA,MAAMC,kBAAkBC,WAAY,UAASA,OAAQ,EAArD;AAEP;;;;;;;;;;AAMO,MAAMC,yBAA0BC,IAAD,IAAU;AAC9C,QAAM;AAAEC,YAAQ;AAAEC;AAAF;AAAV,MAAyBF,IAA/B;AACA,SAAOE,MAAP;AACD,CAHM","sourcesContent":["const getLastItem = (array) => {\n  const item = array[array.length - 1]\n  return item\n}\nconst getItemsFrom = (array, from) => array.slice(from)\n\n/**\n * Get a segment of the stack string, defaults are from = 0 and oneLine = false.\n * @param {string} stack the stack string\n * @param {number} [from=0] index from which to slice from\n * @param {boolean} [oneLine=false] Whether just first line must be returned\n * @returns {string} A stack segment starting from the specified line.\n */\nexport const getStackSegment = (stack, from = 0, oneLine = false) => {\n  if (from === 0 && !oneLine) {\n    return stack\n  }\n  const splitStack = stack\n    .split('\\n', oneLine ? from + 1 : Number.Infinity)\n  if (oneLine) {\n    const line = getLastItem(splitStack)\n    return line\n  } else {\n    const items = getItemsFrom(splitStack, from)\n    return items.join('\\n')\n  }\n}\n\n/**\n * Get the stack trace part of when the erotic function was called. Disregards\n * first two lines.\n * @param {string} stack error's stack\n * @param {number} [transparent] trim the top line as well\n * @returns {string} A part of stack\n * @private\n */\nexport const getEntryStack = (stack, transparent) => {\n  const stackSegment = getStackSegment(stack, 2 + (transparent ? 1 : 0))\n  return stackSegment\n}\n\n/**\n * Get stack line of where the callback was called.\n * @param {string} stack Stack string.\n * @returns {string} Stack line.\n */\nexport const getCalleeStackLine = (stack) => {\n  const calleeStackLine = getStackSegment(stack, 2, true)\n  return calleeStackLine\n}\n\nexport const getStackHeading = message => `Error: ${message}`\n\n/**\n * Extract caller from function's `arguments`.\n * @param {object} args arguments\n * @returns {function} The caller function from arguments.callee.caller.\n * @private\n */\nexport const getCallerFromArguments = (args) => {\n  const { callee: { caller } } = args\n  return caller\n}\n"],"file":"lib.js"}